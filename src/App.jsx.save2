import * as React from 'react';
import AppBar from '@mui/material/AppBar';
import Container from '@mui/material/Container';
import Toolbar from '@mui/material/Toolbar';
import Typography from '@mui/material/Typography';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import SpeedDial from '@mui/material/SpeedDial';

import { RichTreeView } from '@mui/x-tree-view/RichTreeView';

import Ajv from 'ajv';
import AjvAddFormats from 'ajv-formats';
import AvjAddFormatsDraft2019 from 'ajv-formats-draft2019';

import './App.css';
import BurgerMenu from './BurgerMenu';
import ComponentEditDialog from './ComponentEditDialog';
import ComponentEdit from './ComponentEdit';
import NewComponentDialog from './NewComponentDialog';

// Load json schema
import spdx_schema from './assets/spdx.schema.json';
import jsf_0_82_schema from './assets/jsf-0.82.schema.json';
import { Paper } from '@mui/material';


function loadTextFile() {
  const loadBtn = document.getElementById("__loadFileBtn");
  loadBtn.click();
  const p = new Promise(function(resolve) {
    loadBtn.addEventListener("cancel", () => {
      resolve(null);
    });
    loadBtn.addEventListener("change", () => {
      const files = loadBtn.files;
      if (files.length == 0) {
        resolve(null);
      }
      const reader = new FileReader();
      reader.onload = () => {
        resolve(reader.result)
      };
      reader.readAsText(files[0]);  
    });
  });
  return p;
}


async function loadBom(setBom) {
  const text = await loadTextFile();
  if (text === null) {
    return;
  }
  var bom = null;
  const versions = ["1.2", "1.3", "1.4", "1.5", "1.6"];
  const ajv = new Ajv({strict: false});
  AjvAddFormats(ajv);
  AvjAddFormatsDraft2019(ajv);
  ajv.addSchema(spdx_schema, 'spdx.schema.json');
  ajv.addSchema(jsf_0_82_schema, 'jsf-0.82.schema.json');

  try {
    bom = JSON.parse(text);
    if (bom["specVersion"] === undefined) {
      throw new Error("specVersion not defined");
    }
    if (! versions.includes(bom["specVersion"])) {
      throw new Error("Unsupported specVersion");
    }
    // TODO: fix absolute path
    const schema_url = "/src/assets/bom-" + bom["specVersion"] + ".schema.json";
    const req = await fetch(schema_url);
    const cyclonedx_schema = await req.json();
    const validate = ajv.compile(cyclonedx_schema);
    if (validate(bom) === false) {
      console.log(validate.errors);
      throw new Error(ajv.errorsText(validate.errors));
    }
  } catch (error) {
    console.log("Error: " + error.name + " / " + error.message);
    return;
  }
  setBom(bom);
}

function treeViewGetItemId(component) {
  return component["_id"];
}

function treeViewGetItemLabel(component) {
  if (component["version"] !== undefined) {
    return `${component.name} (${component.version})`;
  }
  return component.name;
}

function treeViewGetItemChildren(component) {
  if (component.components !== undefined) {
    return component.components;
  }
  return new Array();
}

function foreachComponent(bom, func) {
  function walk(base) {
    var cnt, res;
    if (base["components"] !== undefined) {
      for (let i = 0; i < base["components"].length; i++) {
        [cnt, res] = func(base.components[i]);
        if (cnt == false) {
          break;
        }
        [cnt, res] = walk(base.components[i])
        if (cnt == false) {
          break;
        }
      }
    }
    return [cnt, res];
  }
  const [, res] = walk(bom);
  return res;
}

function componentsAddId(bom) {
  foreachComponent(bom, (c) => {
    c["_id"] = crypto.randomUUID();
    return [true, undefined];
  });
}

function componentLookup(bom, id) {
  const res = foreachComponent(bom, (c) => {
    if (c["_id"] === id) {
      return [false, c];
    }
    return [true, undefined];
  });
  return res;
}

function CustomTabPanel(props) {
  const { children, value, index, ...other } = props;

  if (value !== index) return (<></>);

  return (
    <Box
      role="tabpanel"
      hidden={value !== index}
      id={`simple-tabpanel-${index}`}
      aria-labelledby={`simple-tab-${index}`}
      {...other}
    >
     {children}
    </Box>
  );
}

function App() {
  let bom = React.useRef({})
  const [componentsList, setComponentsList] = React.useState(Array());
  const [component, setComponent] = React.useState(null);
  const [newCmpOpen, setNewCmpOpen] = React.useState(false);
  const [tabValue, setTabValue] = React.useState(0);

  function componentChangeValue(key, value) {
    component[key] = value;
  }

  function refreshTree() {
    setComponentsList([...bom.current.components]);
  }
  
  function bomLoaded(newBom) {
    componentsAddId(newBom);
    bom.current = newBom;
    if (newBom["components"] !== undefined) {
      setComponentsList(newBom["components"]);
      setComponent({});
    }
  }

  function treeItemClicked(event, id) {
    const c = componentLookup(bom.current, id);
    if (c !== undefined) {
      setComponent(c);
    } else {
      console.log("Error: Component not found")
    }
  }

  const burgerMenuItems = [
    ["New", () => {
        setComponentList([]);  
        }
    ],
    ["Load", () => {
        loadBom(bomLoaded);
      }
    ],
    ["Save", () => {
    }],
  ];

  function newCmpDialogOpen() {
    setNewCmpOpen(true);
  }

  function newCmpDialogSave(formData) {
    console.log(formData);
    let target;
    const subCmp = formData.get("subComponent");
    if ( subCmp !== undefined && subCmp == "on") {
      target = component;
    } else {
      console.log("debug1");
      target = bom.current;
    }
    if (target["components"] === undefined) {
      target["components"] = new Array();
    }
    let newCmp = {
      _id: crypto.randomUUID(),
      name: formData.get("name"),
      type: formData.get("type"),
    }
    target.components.push(newCmp);
    console.log(target.components);
    setNewCmpOpen(false);
    setComponentsList([...bom.current.components]);
    setComponent(newCmp);
  }

  function newCmpDialogCancel() {
    setNewCmpOpen(false);
  }

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  return (
    // 1. Haupt-Container (Vertikale Flexbox für AppBar + Content)
    <>
      <NewComponentDialog open={newCmpOpen} askSub={component != null} okAction={newCmpDialogSave} cancelAction={newCmpDialogCancel}/>
      <Box sx={{display: "none"}}><input type="file" id="__loadFileBtn"/></Box>
      <Box
        sx={{ 
          display: 'flex', 
          flexDirection: 'column', 
          height: '100vh', // Volle Viewport-Höhe
          overflow: 'hidden' // Verhindert Scrollen auf der Hauptebene
        }}
      >
        {/* #1 AppBar (nimmt festen Platz ein) */}
        <AppBar position="static">
          <Toolbar>
            <BurgerMenu items={burgerMenuItems}/>
            <Typography variant="h6" component="div">
              CycloneDX Editor
            </Typography>
          </Toolbar>
        </AppBar>
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange}>
            <Tab label="Metadata"/>
            <Tab label="Components"/>
          </Tabs>
        </Box>

        <CustomTabPanel value={tabValue} index={0}>Tab 1</CustomTabPanel>
        <CustomTabPanel value={tabValue} index={1} sx={{ display: 'flex',  flexDirection: 'column', minHeight: 0, flexGrow: 1}}>

          <Toolbar variant='dense'>
            <Button sx={{ mr: 2 }} variant='text' onClick={newCmpDialogOpen}>New</Button>
            <Button sx={{ mr: 2 }} variant='text'>Delete</Button>
          </Toolbar>

          {/* 2. Content-Container (Horizontale Flexbox für RichTreeView + Box) */}
          <SpeedDial ariaLabel='foo' sx={{ position: 'absolute', bottom: 20, right: 20 }}></SpeedDial>

          <Paper
            elevation={2} 
            sx={{ 
              display: 'flex', 
              flexGrow: 1, // Nimmt die gesamte verbleibende Höhe ein
              minHeight: 0, // Wichtig für Flexbox, um korrekte Höhenberechnung bei scrollbarem Inhalt zu gewährleisten,
              m: 1
            }}
          >
            {/* #2 RichTreeView (nimmt 30% Breite ein, scrollt bei Überlauf) */}
            <Box 
              sx={{ 
                width: '30%', 
                borderRight: '1px solid grey', 
                overflow: 'auto', // Fügt Scrollbalken bei vertikalem Überlauf hinzu
                p: 2,
              }}
            >
              <RichTreeView
                sx={{alignItems: 'left'}}
                items={componentsList}
                getItemId={treeViewGetItemId}
                getItemLabel={treeViewGetItemLabel}
                getItemChildren={treeViewGetItemChildren}
                expansionTrigger='iconContainer'
                onItemClick={treeItemClicked}
              />

            </Box>

            {/* #3 Box (nimmt 70% Breite ein, scrollt bei Überlauf) */}
            <Box
              sx={{ 
                width: '70%', 
                overflow: 'auto', // Fügt Scrollbalken bei vertikalem Überlauf hinzu
                p: 1,
                m: 1,
              }}
            >
                <ComponentEdit
                  component={component}
                  changeValue={componentChangeValue}
                  focusLoss={refreshTree}
                />  
            </Box>
          </Paper>
        </CustomTabPanel>
      </Box>
    </>
  );
}

export default App
